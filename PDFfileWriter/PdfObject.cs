/////////////////////////////////////////////////////////////////////
//
//	PdfFileWriter
//	PDF File Write C# Class Library.
//
//	PdfObject
//	Base class for all PDF indirect object classes.
//
//	Granotech Limited
//	Author: Uzi Granot
//	Version: 1.0
//	Date: April 1, 2013
//	Copyright (C) 2013 Granotech Limited. All Rights Reserved
//
//	PdfFileWriter C# class library and TestPdfFileWriter test/demo
//  application are free software.
//	They is distributed under the Code Project Open License (CPOL).
//	The document PdfFileWriterReadmeAndLicense.pdf contained within
//	the distribution specify the license agreement and other
//	conditions and notes. You must read this document and agree
//	with the conditions specified in order to use this software.
//
//	Version History:
//
//	Version 1.0 2013/04/01
//		Original revision
//	Version 1.1 2013/04/09
//		Allow program to be compiled in regions that define
//		decimal separator to be non period (comma)
//	Version 1.2 2013/07/21
//		The original revision supported image resources with
//		jpeg file format only.
//		Version 1.2 support all image files acceptable to Bitmap class.
//		See ImageFormat class. The program was tested with:
//		Bmp, Gif, Icon, Jpeg, Png and Tiff.
//
/////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace PdfFileWriter
{
////////////////////////////////////////////////////////////////////
// PdfObject Class
// PDF indirect object base class
// User program cannot call it directly
////////////////////////////////////////////////////////////////////

public class PdfObject : IComparable<PdfObject>
	{
	internal	PdfDocument			Document;			// PDF parent document
	internal	Int32				ObjectNumber;		// PDF indirect object number
	internal	String				ResourceCode;		// resource code automatically generated by the program
	internal	Int32				FilePosition;		// PDF file position for this indirect object
	internal	StringBuilder		ContentsString;		// contents objects commands (page contents, X objects and tiling patterns)
	protected	Double				ScaleFactor;		// scale factor from user unit of measure to points
	private		List<PdfDictionary> Dictionary;			// indirect objects dictionary or stream dictionary

	////////////////////////////////////////////////////////////////////
	// Constructor for objects with no /Type in their dictionary
	// Note: access is internal. Used by derived classes only
	////////////////////////////////////////////////////////////////////

	internal PdfObject
			(
			PdfDocument	Document,		// link to PdfDocument the main class
			Boolean		Stream			// true if the indirect object is a stream, false otherwise
			) : this(Document, Stream, null) {}

	////////////////////////////////////////////////////////////////////
	// Constructor for objects with /Type in their dictionary
	// Note: access is internal. Used by derived classes only
	////////////////////////////////////////////////////////////////////

	internal PdfObject
			(
			PdfDocument	Document,		// link to PdfDocument the main class
			Boolean		Stream,			// true if the indirect object is a stream, false otherwise
			String		ObjectType		// object type (i.e. /Catalog, /Pages, /Font, /XObject)
			)
		{
		// save link to main document object
		this.Document = Document;

		// save scale factor
		ScaleFactor = Document.ScaleFactor;

		// if object is stream define empty dictionary and empty contents stream
		if(Stream)
			{
			Dictionary = new List<PdfDictionary>();
			ContentsString = new StringBuilder();
			}

		// set PDF indirect object number to next available number
		this.ObjectNumber = Document.ObjectArray.Count + 1;

		// if object name is specified, create a dictionary and add /Type Name entry
		if(!String.IsNullOrEmpty(ObjectType)) AddToDictionary("/Type", ObjectType);

		// add the new object to object array
		Document.ObjectArray.Add(this);
		return;
		}

	////////////////////////////////////////////////////////////////////
	// Compare the resource codes of two PDF objects
	// Used by PdfContents to maintain resource objects in sorted order.
	////////////////////////////////////////////////////////////////////

	public Int32 CompareTo
			(
			PdfObject Other		// the second object
			)
		{
		return(String.Compare(this.ResourceCode, Other.ResourceCode));
		}

	////////////////////////////////////////////////////////////////////
	// Convert user coordinates or line width to points.
	// The result is rounded to 6 decimal places and converted to Single.
	////////////////////////////////////////////////////////////////////

	internal Single ToPt
			(
			Double	Value		// coordinate value in user unit of measure
			)
		{
		return((Single) Math.Round(ScaleFactor * Value, 6, MidpointRounding.AwayFromZero));
		}

	////////////////////////////////////////////////////////////////////
	// Round unscaled numbers.
	// The value is rounded to 6 decimal places and converted to Single
	////////////////////////////////////////////////////////////////////

	internal Single Round
			(
			Double	Value		// a number to be saved in contents
			)
		{
		return((Single) Math.Round(Value, 6, MidpointRounding.AwayFromZero));
		}

	////////////////////////////////////////////////////////////////////
	// Find key value pair in dictionary.
	// return index number or -1 if not found.
	////////////////////////////////////////////////////////////////////
	
	internal Int32 FindKeyInDictionary
			(
			String		Key		// key (first character must be forward slash /)
			)
		{
		// make sure dictionary is defined
		if(Dictionary != null)
			{
			// look through the dictionary
			for(Int32 Index = 0; Index < Dictionary.Count; Index++) if(Dictionary[Index].Key == Key) return(Index);
			}

		// no dictionary or not found
		return(-1);
		}

	////////////////////////////////////////////////////////////////////
	// Add key value pair to dictionary.
	// If dictionary does not exist, create it.
	// If key is not found, add the pair as new entry.
	// If key is found, replace old pair with new one.
	////////////////////////////////////////////////////////////////////
	
	internal void AddToDictionary
			(
			String		Key,	// key (first character must be forward slash /)
			String		Value	// value
			)
		{
		// create dictionary if not defined
		if(Dictionary == null) Dictionary = new List<PdfDictionary>();

		// search for existing key
		Int32 Index = FindKeyInDictionary(Key);

		// not found
		if(Index < 0)
			// add new pair
			Dictionary.Add(new PdfDictionary(Key, Value));

		// found
		else
			// replace value
			Dictionary[Index].Value = Value;

		// exit
		return;
		}

	////////////////////////////////////////////////////////////////////
	// Add key value pair to dictionary.
	// The value is a reference to indirect object number.
	// If dictionary does not exist, create it.
	// If key is not found, add the pair as new entry.
	// If key is found, replace old pair with new one.
	////////////////////////////////////////////////////////////////////
	
	internal void AddToDictionary
			(
			String		Key,	// key (first character must be forward slash /)
			PdfObject	Obj		// PdfObject. The method creates an indirect reference "n 0 R" to the object.
			)
		{
		AddToDictionary(Key, String.Format("{0} 0 R", Obj.ObjectNumber));
		return;
		}

	////////////////////////////////////////////////////////////////////
	// Get dictionary value
	// Return String if key is found, null if not
	////////////////////////////////////////////////////////////////////
	
	internal String GetDictionaryValue
			(
			String		Key		// key (first character must be forward slash /)
			)
		{
		Int32 Index = FindKeyInDictionary(Key);
		return(Index >= 0 ? Dictionary[Index].Value : null);
		}

	////////////////////////////////////////////////////////////////////
	// Convert resource dictionary to one String.
	// This method is called at the last step of document creation
	// from within PdfDocument.CreateFile(FileName).
	// it is relevant to page contents, X objects and tiled pattern
	// Return value is resource dictionary string.
	////////////////////////////////////////////////////////////////////
	
	internal String BuildResourcesDictionary
			(
			List<PdfObject>		ResObjects,		// list of resource objects for this contents
			Boolean				AddProcSet		// for page contents we need /ProcSet 
			)
		{
		// resources dictionary content initialization
		StringBuilder Resources = new StringBuilder("<<");

		// for page object
		if(AddProcSet) Resources.AppendFormat("/ProcSet {0} 0 R\n", Document.ProcSetObject.ObjectNumber);

		// resource object list is not empty
		if(ResObjects != null && ResObjects.Count > 0)
			{
			// fonts
			Boolean Fonts = false;
			foreach(PdfObject Resource in ResObjects)
				{
				if(Resource.GetType() != typeof(PdfFont)) continue;
				if(!Fonts)
					{
					Resources.Append("/Font <<");
					Fonts = true;
					}
				Resources.Append(String.Format("{0} {1} 0 R", Resource.ResourceCode, Resource.ObjectNumber));
				}
			if(Fonts) Resources.Append(">>\n");

			// images and XObjects
			Boolean XObjects = false;
			foreach(PdfObject Resource in ResObjects)
				{
				// ignore all but images and XObjects
				if(Resource.GetType() != typeof(PdfImage) && Resource.GetType() != typeof(PdfXObject)) continue;

				// first image or XObject
				if(!XObjects)
					{
					Resources.Append("/XObject <<");
					XObjects = true;
					}

				// append indirect object number
				Resources.Append(String.Format("{0} {1} 0 R", Resource.ResourceCode, Resource.ObjectNumber));
				}

			// terminate
			if(XObjects) Resources.Append(">>\n");

			// patterns
			Boolean Patterns = false;
			foreach(PdfObject Resource in ResObjects)
				{
				// all but tiling patterns
				if(Resource.GetType() != typeof(PdfTilingPattern)) continue;

				// first pattern found
				if(!Patterns)
					{
					Resources.Append("/Pattern <<");
					Patterns = true;
					}

				// append indirect object number
				Resources.Append(String.Format("{0} {1} 0 R", Resource.ResourceCode, Resource.ObjectNumber));
				}

			// terminate
			if(Patterns) Resources.Append(">>\n");

			// patterns
			Boolean Shading = false;
			foreach(PdfObject Resource in ResObjects)
				{
				// all but tiling patterns
				if(Resource.GetType() != typeof(PdfAxialShading) && Resource.GetType() != typeof(PdfRadialShading)) continue;

				// first pattern found
				if(!Shading)
					{
					Resources.Append("/Shading <<");
					Shading = true;
					}

				// append indirect object number
				Resources.Append(String.Format("{0} {1} 0 R", Resource.ResourceCode, Resource.ObjectNumber));
				}

			// terminate
			if(Shading) Resources.Append(">>\n");
			}

		// terminate resource dictionary
		Resources.Append(">>");

		// exit
		return(Resources.ToString());
		}

	////////////////////////////////////////////////////////////////////
	// Write object to PDF file
	// Called by PdfDocument.CreateFile(FileName) method
	// to output one indirect PDF object.
	// It is a virtual method. Derived classes can overwrite it.
	////////////////////////////////////////////////////////////////////

	internal virtual void WriteObjectToPdfFile
			(
			BinaryWriter PdfFile		// output file
			)
		{
		// write object header
		PdfFile.Write(Encoding.ASCII.GetBytes(String.Format("{0} 0 obj\n", ObjectNumber)));

		// we have contents stream
		if(ContentsString != null && ContentsString.Length > 0)
			{
			// contents in bytes
			Byte[] ByteContents = new Byte[ContentsString.Length];

			// convert content from string to binary
			// do not use Encoding.ASCII.GetBytes(...)
			for(Int32 Index = 0; Index < ContentsString.Length; Index++) ByteContents[Index] = (Byte) ContentsString[Index];

			// stream
			if(Dictionary != null)
				{
				// for testing compression can be disabled
				if(!Document.Debug)
					{
					// compress stream
					DeflateZLib Deflate = new DeflateZLib();
					Byte[] CompContents = Deflate.Compress(ByteContents);
					if(CompContents != null)
						{
						ByteContents = CompContents;
						AddToDictionary("/Filter", "/FlateDecode");
						}
					}

				// stream length
				Dictionary.Add(new PdfDictionary("/Length", ByteContents != null ? ByteContents.Length.ToString() : "0"));

				// write dictionary
				DictionaryToPdfFile(PdfFile);

				// write stream reserved word
				PdfFile.Write(Encoding.ASCII.GetBytes("stream\n"));

				// write content to pdf file
				if(ByteContents != null) PdfFile.Write(ByteContents);

				// write end of stream
				PdfFile.Write(Encoding.ASCII.GetBytes("\nendstream\n"));
				}

			// we have contents but no dictionary
			else
				{
				// write content to pdf file
				PdfFile.Write(ByteContents);
	
				// final terminator
				PdfFile.Write('\n');
				}
			}

		// no contents
		else
			{
			// we have a dictionary
			if(Dictionary != null)
				{
				// write dictionary
				DictionaryToPdfFile(PdfFile);
				}

			// no contents and no dictionary
			else
				{
				throw new ApplicationException("Empty object");
				}
			}

		// output object trailer
		PdfFile.Write(Encoding.ASCII.GetBytes("endobj\n"));
		return;
		}

	////////////////////////////////////////////////////////////////////
	// Write dictionary to PDF file
	// Called from WriteObjectToPdfFile to output a dictionary
	////////////////////////////////////////////////////////////////////
	
	internal void DictionaryToPdfFile
			(
			BinaryWriter	PdfFile		// output file
			)
		{
		Int32 EolMarker = 100;
		StringBuilder Str = new StringBuilder("<<");

		// output dictionary
		foreach(PdfDictionary Dict in Dictionary)
			{
			// add new line to cut down very long lines
			if(Str.Length > EolMarker)
				{
				Str.Append("\n");
				EolMarker = Str.Length + 100;
				}

			// add key value pair
			if(Dict.Value[0] == '/' || Dict.Value[0] == '[' || Dict.Value[0] == '<' || Dict.Value[0] == '(')
				Str.AppendFormat("{0}{1}", Dict.Key, Dict.Value);
			else
				Str.AppendFormat("{0} {1}", Dict.Key, Dict.Value);
			}

		// terminate dictionary
		Str.Append(">>\n");

		// write to pdf file
		PdfFile.Write(Encoding.ASCII.GetBytes(Str.ToString()));
		return;
		}
	}

////////////////////////////////////////////////////////////////////
// Dictionary key value pair class
// Holds one key value pair
////////////////////////////////////////////////////////////////////

internal class PdfDictionary
	{
	internal String		Key;		// key first character must be forward slash ?
	internal String		Value;		// value associated with key

	////////////////////////////////////////////////////////////////////
	// Constructor
	////////////////////////////////////////////////////////////////////

	internal PdfDictionary
			(
			String		Key,		// key first character must be forward slash ?
			String		Value		// value associated with key
			)
		{
		if(Key[0] != '/') throw new ApplicationException("Dictionary key must start with /");
		this.Key = Key;
		this.Value = Value;
		return;
		}
	}
}
